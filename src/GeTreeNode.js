/*# > Object < #*/var GeTreeNode = Class.create(GeObject, {    /*# > Method < #*/    initialize: function($super, parent) {        $super();        this.set_parent(parent);        this.childs = new GeLinkedList();		this.iterator = this.childs.iterator();        this._init(parent);        Log.w("[" + this.id + "] Creating node tree: " + this.type);    },    /*# > Method < #*/    _init: function(parent) {        this.type = "basic";        this.bPhysUpdate = false;        this.bRedraw = false;    },    /*# > Method < #*/    set_parent: function(parent) {        this.parent = parent;    },    /*# > Method < #*/    set_physUpdate: function(bool) {        this.bPhysUpdate = bool;    },    /*# > Method < #*/    set_redraw: function(bool) {        this.bRedraw = bool;    },    /*# > Method < #*/    hide: function() {        this.set_redraw(false);		this.iterator.reset_head();		//var it = this.childs.iterator();		var child;		while(child = this.iterator.next()) {            child.data.hide();        }    },    /*# > Method < #*/    unhide: function() {        this.set_redraw(true);		this.iterator.reset_head();		//var it = this.childs.iterator();		var child;		while(child = this.iterator.next()) {			child.data.unhide();		}    },    /*# > Method < #*/    hidden: function() {        return !this.bRedraw;    },    /*# > Method < #*/    freeze: function() {        this.set_physUpdate(false);		this.iterator.reset_head();		var child;		while(child = this.iterator.next()) {            child.data.freeze();        }    },    /*# > Method < #*/    unfreeze: function() {        this.set_physUpdate(true);		this.iterator.reset_head(); 		//var it = this.childs.iterator();		var child;		while(child = this.iterator.next()) {			child.data.unfreeze();        }    },    /*# > Method < #*/    frozen: function() {        return !this.bPhysUpdate;    },    /*# > Method < #*/    get_parent: function() {        return this.parent;    },    /*# > Method < #*/    get_childs: function() {        return this.childs;    },    /*# > Method < #*/    add_child: function(node) {		node.parent = this;		this.childs.add(node);    },		enable_physics: function() {		if (!this.phys) {			this.phys = new GePhysState(this);		}	},    /*# > Method < #*/    update: function(dt) {		//Log.w("Update " + this.core_id);        if (this.phys && !this.frozen()) {            this.phys.update(dt);            var c = this.collide();            if (c) {  c.correct(); 					  c.response(); }        }		//ShoGE.Grid.replace(this);		if (this.postupdate) { this.postupdate(dt) };       	//var it = this.childs.iterator();		this.iterator.reset_head();		var child;		while(child = this.iterator.next()) {		    if (child.data.phys && !child.data.frozen()) {                child.data.phys.update(dt);                var c = child.data.collide();                if (c) {  c.correct();						  c.response(); }            }			if (child.data.postupdate) {				child.data.postupdate(dt);			}        }    },	//postupdate: function(dt) {		//; // STUB	//},    /*# > Method < #*/    collide: function() {        if (this.frozen()) {            return null;        }        if (!this.bound) {           // Log.w("No bound for object " + this.id);			return null;        }        if (this.bound.shadow) {            this.bound.shadow.collide(ShoGE.Core.SG);        }        if (this.bound.circle) {            var c = this.bound.circle.collide(ShoGE.Core.SG);			//if (c) Log.w("Collide");			return c;		}		return null;    },    /*# > Method < #*/    draw: function(ctx) {        ctx.save();        if (this.gx && !this.hidden()) {			ctx.save();            this.gx.draw(ctx);			ctx.restore();        }		this.iterator.reset_head();        //var it = this.childs.iterator();		var child;		while(child = this.iterator.next()) {	        if (child.data.gx && !child.data.hidden()) {                ctx.save();				child.data.gx.draw(ctx);				ctx.restore();            }        }        ctx.restore();    }});